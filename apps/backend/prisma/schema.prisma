generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- MODELOS PRINCIPAIS ---

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  clients         Client[]
  products        Product[]
  sales           Sale[]
  accountsPay     AccountPay[]
  accountsRec     AccountRec[]
  contasCorrentes ContaCorrente[]
  contasContabeis ContaContabil[]
  settings        UserSettings?
  XmlImportLog    XmlImportLog[]
  transacoes      Transacao[] // ✅ ADICIONE ESTA LINHA
}

model Product {
  id             String          @id @default(uuid())
  userId         String
  user           User            @relation(fields: [userId], references: [id])
  name           String
  description    String?
  price          Decimal         @db.Decimal(10, 2)
  stock          Int
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  saleItems      SaleItem[]
  stockMovements StockMovement[] // ✅ A relação existe aqui
}

// ✅ E O MODELO ESTÁ DE VOLTA AQUI
model StockMovement {
  id        String   @id @default(uuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  type      String // "IN", "OUT_SALE", "ADJUSTMENT"
  quantity  Int
  createdAt DateTime @default(now())
}

model Sale {
  id            String       @id @default(uuid())
  userId        String
  user          User         @relation(fields: [userId], references: [id])
  clientId      String
  client        Client       @relation(fields: [clientId], references: [id])
  orderNumber   String       @unique
  totalAmount   Decimal      @db.Decimal(10, 2)
  // ✅ ADICIONANDO OS CAMPOS QUE FALTAVAM
  feeAmount     Decimal?     @db.Decimal(10, 2)
  netAmount     Decimal?     @db.Decimal(10, 2)
  paymentMethod String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  saleItems     SaleItem[]
  accountsRec   AccountRec[]
}

// ... todos os outros modelos que já estavam corretos ...

model Client {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id])
  name            String
  email           String?   @unique
  phone           String?
  address         String?
  birthDate       DateTime?
  gender          String?
  preferences     String?
  purchaseHistory Json?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  sales           Sale[]
}

model SaleItem {
  id        String   @id @default(uuid())
  saleId    String
  sale      Sale     @relation(fields: [saleId], references: [id])
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  quantity  Int
  price     Decimal  @db.Decimal(10, 2)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum TipoTransacaoPrisma {
  CREDITO
  DEBITO
}

enum TipoContaContabilPrisma {
  ATIVO
  PASSIVO
  PATRIMONIO_LIQUIDO
  RECEITA
  DESPESA
}

model AccountPay {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  description String
  amount      Decimal   @db.Decimal(10, 2)
  dueDate     DateTime
  paid        Boolean   @default(false)
  paidAt      DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model AccountRec {
  id              String         @id @default(uuid())
  userId          String
  user            User           @relation(fields: [userId], references: [id])
  saleId          String?
  sale            Sale?          @relation(fields: [saleId], references: [id])
  description     String
  amount          Decimal        @db.Decimal(10, 2)
  dueDate         DateTime
  received        Boolean        @default(false)
  receivedAt      DateTime?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  contaCorrenteId String?
  contaCorrente   ContaCorrente? @relation(fields: [contaCorrenteId], references: [id])
}

model ContaContabil {
  id               String                  @id @default(uuid())
  userId           String
  user             User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  codigo           String
  nome             String
  tipo             TipoContaContabilPrisma
  aceitaLancamento Boolean                 @default(true)
  contaPaiId       String?
  contaPai         ContaContabil?          @relation("SubContas", fields: [contaPaiId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  subContas        ContaContabil[]         @relation("SubContas")
  transacoes       Transacao[]
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt

  @@unique([userId, codigo])
  @@map("contas_contabeis")
}

model ContaCorrente {
  id          String       @id @default(uuid())
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  nome        String
  numeroConta String
  agencia     String?
  saldo       Decimal      @db.Decimal(10, 2)
  moeda       String       @default("BRL")
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?
  transacoes  Transacao[]
  accountsRec AccountRec[]

  @@unique([userId, numeroConta])
  @@map("contas_correntes")
}

model Transacao {
  id              String              @id @default(uuid())
  // ✅ PADRONIZANDO: A transação sempre pertence a um usuário
  userId          String
  user            User                @relation(fields: [userId], references: [id])
  tipo            TipoTransacaoPrisma
  valor           Decimal             @db.Decimal(10, 2)
  moeda           String
  descricao       String?
  dataHora        DateTime            @default(now()) // ✅ Verifique se este campo existe
  contaContabilId String
  contaContabil   ContaContabil       @relation(fields: [contaContabilId], references: [id])
  contaCorrenteId String?
  contaCorrente   ContaCorrente?      @relation(fields: [contaCorrenteId], references: [id], onDelete: NoAction)
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@map("transacoes")
}

model XmlImportLog {
  id        String   @id @default(cuid())
  nfeKey    String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
}

model UserSettings {
  id                    String  @id @default(uuid())
  userId                String  @unique
  user                  User    @relation(fields: [userId], references: [id])
  defaultReceitaContaId String?
  defaultCaixaContaId   String?
  defaultDespesaContaId String?

  @@map("user_settings")
}
